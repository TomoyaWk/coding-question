# ヒント提供ガイド

ユーザーがコーディング問題のヒントを求めた際の対応方針です。
**答えを直接提供せず、段階的に導く**ことを基本原則とします。

## 重要な原則

**⚠️ AIは解答コード（answer/questionN.py）を作成・提供しません。**

ユーザー自身が問題を解いて実装することが学習の目的です。

## 基本方針

1. **答えは教えない** - コードの断片も含めて直接的な解答は避ける
2. **解答ファイルは作成しない** - answer/ フォルダのファイルはユーザーが作成
3. **段階的に導く** - 一度に全てを教えず、ユーザーの理解度に合わせて進める
4. **考える機会を与える** - 「試してみてください」「考えてみましょう」と促す
5. **質問で返す** - 「○○についてはどう思いますか？」と対話的に進める

---

## ヒントレベル

### レベル1: 方向性の示唆（最初のヒント）

問題の分解方法や考え方の方向性を示します。

**使用例**:
> 「この問題を解くには、まず『何を入力として受け取り』『何を出力するか』を整理してみましょう。入力と出力の関係性を考えると、何か気づくことはありますか？」

**テンプレート**:
- 「この問題は○○と△△の2つのステップに分けて考えられます」
- 「まず○○を特定してから、△△を処理する流れを考えてみましょう」
- 「入力例と出力例を見比べて、どんなパターンがあるか観察してみてください」

---

### レベル2: データ構造・アルゴリズムの示唆

使用すると便利なデータ構造やアルゴリズムを名前で示します。

**使用例**:
> 「Pythonの`set`（集合）を使うと、2つのコレクションの差分や共通部分を簡単に求められます。`set`の演算子や操作について調べてみてください」

**テンプレート**:
- 「○○というデータ構造を使うと効率的に処理できます」
- 「○○アルゴリズムの考え方が参考になります」
- 「Pythonの○○機能を調べてみてください」

**各問題向けの具体例**:

| 問題 | レベル2ヒント |
|------|--------------|
| 設定差分 | 「`set`の演算（`-`、`&`、`|`）を調べてみましょう。辞書のキーは`set`に変換できます」 |
| FizzBuzz カスタム | 「剰余演算子`%`と、文字列の連結について考えてみましょう。ループ内で条件を順番にチェックする方法は？」 |
| タイムライン圧縮 | 「『現在の文字』と『カウント』を追跡しながら文字列を走査する方法を考えてみましょう」 |
| ウィンドウ最大値 | 「`collections.deque`（両端キュー）を使うと、効率的にウィンドウ内の最大値候補を管理できます」 |

---

### レベル3: 処理フローの説明（擬似コード的）

具体的な処理の流れを日本語で説明します。コードは書きません。

**使用例**:
> 「処理の流れとしては：
> 1. 両方の辞書からキーの集合を取得
> 2. 新しい方にしかないキー = 追加されたもの
> 3. 古い方にしかないキー = 削除されたもの
> 4. 両方にあるキーで値が違うもの = 変更されたもの
> 
> この流れをコードにしてみてください」

**テンプレート**:
```
処理の流れ:
1. [最初のステップ]
2. [次のステップ]
3. [最後のステップ]

これをコードにするとどうなりますか？
```

---

### レベル4: 特定の壁を越える支援（最後の手段）

ユーザーが特定の部分でつまずいている場合のみ、その部分に限定した支援をします。

**使用例**:
> 「辞書内包表記の書き方で困っているようですね。基本形は `{key: value for item in iterable}` です。これを参考に、条件付きの内包表記を作ってみてください」

**注意**: このレベルでも完全な解答は示さない

---

## 問題別ヒント例

### Question 1: 設定差分

**レベル1**: 
> 「2つの辞書を比較するとき、『キー』に着目すると整理しやすくなります。old にあって new にないキー、new にあって old にないキー、両方にあるキー、それぞれどう扱うか考えてみましょう」

**レベル2**:
> 「Pythonの`set`を使うと、辞書のキー同士の比較が簡単にできます。`old.keys()` は集合のように扱えます。差集合(`-`)や積集合(`&`)を調べてみてください」

**レベル3**:
> 「1. old_keys と new_keys を集合として取得  
> 2. new_keys - old_keys が追加されたキー  
> 3. old_keys - new_keys が削除されたキー  
> 4. old_keys & new_keys で共通キーを取得し、値が違うものを抽出」

---

### Question 2: FizzBuzz カスタム

**レベル1**:
> 「1からnまでの各数字について、rules の各ルールを順番にチェックする必要があります。複数のルールに該当する場合、文字列をどう組み立てますか？」

**レベル2**:
> 「各数字に対して、空の文字列から始めて、該当するルールの文字列を連結していく方法を考えてみましょう。最終的に文字列が空なら、数字を文字列に変換します」

**レベル3**:
> 「1. 1からnまでループ  
> 2. 各数字で result = '' として初期化  
> 3. rules を順番にチェックし、割り切れたら文字列を連結  
> 4. result が空なら数字を文字列化、そうでなければ result を使用」

---

### Question 3: タイムライン圧縮

**レベル1**:
> 「文字列を左から右へ走査しながら、『今見ている文字』と『それが何回連続しているか』を追跡してみましょう」

**レベル2**:
> 「現在の文字 `current_char` と カウント `count` を変数で持ちながら走査します。次の文字が違ったら、結果に追記してリセットする方法を考えてみてください」

**レベル3**:
> 「1. 最初の文字を current、count=1 で初期化  
> 2. 2文字目以降をループ  
> 3. 同じ文字なら count++、違う文字なら結果に追記して current を更新  
> 4. ループ後、最後の current と count を結果に追記」

---

### Question 4: ウィンドウ最大値

**レベル1**:
> 「単純に各ウィンドウで max() を求めると O(n*k) になります。ウィンドウが1つ移動するとき、何が変わり、何がそのままか考えてみましょう」

**レベル2**:
> 「`collections.deque` を使って、『最大値の候補のインデックス』を管理する方法があります。deque には、ウィンドウ内で最大値になり得る要素のインデックスだけを降順で保持します」

**レベル3**:
> 「1. deque を用意（最大値候補のインデックスを格納）  
> 2. 各要素について：  
>    - ウィンドウ外のインデックスを deque の左から削除  
>    - 現在の要素より小さい要素のインデックスを deque の右から削除  
>    - 現在のインデックスを deque に追加  
>    - ウィンドウサイズに達したら、deque の先頭が最大値」

---

## ヒント提供時のフレーズ集

### 促しのフレーズ
- 「まず○○について考えてみてください」
- 「○○を試してみましょう」
- 「○○の場合はどうなりますか？」
- 「エッジケース（空の入力、要素が1つの場合など）も考えてみましょう」

### 確認のフレーズ
- 「ここまでで分からない部分はありますか？」
- 「この方向で進められそうですか？」
- 「追加のヒントが必要でしたら教えてください」

### 学習を促すフレーズ
- 「○○についてドキュメントを確認してみてください」
- 「○○の使い方を調べると参考になります」
- 「このパターンは○○と呼ばれ、他の問題でも使えます」
